#はじめに

Analyticsでキャンペーンとはインハウス・キャンペーン（inhouse campaign)のことを言います。これは、アプリ内のポップアップやバナーを通じてユーザーにイベント（ミッション)を表示し、利用者がイベントを実施した場合、リワードを付与できる機能を提供しています。
Toast Analyticsが提供するインハウス・キャンペーンの機能は、キャンペーンの実施によるユーザーおよび売上の増加に伴う成果分析の結果指標を自動的に確認できます。また、キャンペーンの効率を最大化するために、キャンペーンの目的に合ったターゲットを絞ることができます。

この機能を使うためには、以下のような追加作業が必要です。本ドキュメントは、それらの作業の詳細について説明しています。
1.キャンペーンの表示およびリワードの処理のために、アプリクライアントにToast Analytics SDKの適用が必要です。
2.ユーザーのミッションの達成通知およびリワードの確認のために、ゲームサーバー（またはアプリケーションサーバーとキャンペーンサーバー間の通信が必要です。)

##用語説明
キャンペーンサービスでは、内部的に以下の用語が使われます。

|用語|説明|
|---|---|
|（インハウス)キャンペーン|　アプリの中でポップアップやバナーを通じてユーザーにイベント（ミッション)を表示し、ユーザーがミッションを達成した場合、リワードを付与できるToast Analyticsの機能|
|（キャンペーン)ミッション|　キャンペーンのリワード提供のためにユーザーが達成すべき目標|
|カスタマイズデータ|	カスタマイズデータ|
|（キャンペーン)リワード|　ユーザーがミッションを達成した場合、提供するアプリ内のゲーム内通貨|

##重要な連動項目における説明
Campaignサービスの動作フローは次の図のとおりです。
![Project Sett](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics_JA/master/docs/Developer/images/image003.png)
[図1 サービスの動作フロー]

以下に取り上げられる内容は、連動時に必要な重要項目について簡単に説明したものです。このドキュメントの後半で、その詳細を確認できます。
###1.TOAST Analytics SDKの適用
Analytics Campaignの機能を使うためには、Toast Analytics SDKをアプリに適用する必要があります。
TOAST Analytics SDKの適用に関する内容は、このドキュメントの後半で確認できます。また、別途提供されるToast Analytics APIのリファレンスドキュメントにもその内容が取り上げられています。

###2.キャンペーンの設定
新規キャンペーンを直接作成することもできますが、テンプレートを使うことでより早く簡単に効率の良いキャンペーンを作ることができます。 
Toast Analyticsのウェブサイトにある「キャンペーンの実施」で新しいキャンペーンを登録することができます。これに関する詳細は、該当するページの右上にある「ページガイド」に取り上げられています。

###3.テスト端末の登録
キャンペーンが一般ユーザーに表示される前に、キャンペーンの正常な表示および動作の可否を確認するためにテストを行う必要があります。テストを実施するためには、Toast Analytics SDKでDevice IDおよびDevice Tokenを獲得してからテスト端末を登録します。
Analyticsのウェブサイトの「アプリの設定ボタン」 > 「キャンペーンの設定」 > 「テストデバイスの設定」でテスト端末を登録することができます。

###4.キャンペーンのテストの実施
テスト端末の登録が正常に終わると、Toast Analyticsのウェブサイトの「キャンペーン実施」> 「キャンペーンリスト」 > 「テストボタン」をクリックすることでテストが進みます。

###5.キャンペーンの動作確認
テスト端末でキャンペーンが正常に動作するか確認します。そのためには、次に取り上げられる4ステージにおける進捗状況を確認する必要があります。各ステージの詳細はToast Analyticsのウェブサイトの右上にある「ページガイド」で確認できます。
但し、ミッションの達成およびリワードの検証は、それらの項目における設定が完了しているキャンペーンのみ該当します。
- 表示：キャンペーン情報がテスト端末に正常に受信され、キャンペーンを表示する準備が完了した状態
- 実施：テスト端末にバナーまたはポップアップが表示され、キャンペーンへの参加を開始した状態
- ミッション：ゲームサーバーからキャッシュサーバーにミッションデータの送信が正常に終了した状態
- リワード：キャンペーンサーバーからゲームサーバーへの情報転送が正常に終了した状態

###6.キャンペーンの表示
キャンペーンテストが全て完了すると、外部のユーザーがアクセスできるようにキャンペーンを開始することができます。キャンペーンの開始後、アプリがキャンペーンの表示場所（キャンペーン設定>表示場所の設定を参照)に達した場合、キャンペーンが表示されます。

###7.ミッションの完了およびリワードの付与処理
キャンペーンのミッションを達成するために、ユーザーがある特定の行動（例：レベル、ランキングの変化など)をした場合、ゲームサーバーは、キャンペーンサーバーのAPI（check mission)を呼び出し、ミッションの達成有無を確認できます。 
ミッション達成後は、キャンペーンサーバーからゲームサーバーにリワード情報が送られます。ゲームサーバーは、この情報に基づいてクライアントにリワードを付与します。

#ゲームクライアントの適用

Campaignシステムの動作フローは次の図2のとおりです。
![Project Sett](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics_JA/master/docs/Developer/images/image004.png)

[図2 システムの動作フロー]

##ゲームクライアント

概念の理解を助けるためにJava Codeを用いて説明します。詳細は、プラットフォームごとに提供されるProgramming Guideをご参照下さい。

###1.初期化

キャンペーン機能を使うためには、初期化関数を呼び出す必要があります。

```
GameAnalytics.initializeSdk(getActivity(), appId, entId, appVer,  useLoggingUserId);
```


キャンペーン情報をリクエストする前にCampaign Listenerを登録します。
```
GameAnalytics.setCampaignListener(campaignListener); 
```

Listenerでは以下のCallbackが提供されます。
- onCampaignVisibilityChanged：キャンペーンおよびリワードに関するポップアップ/バナーが画面に表示されたり消えたりするときに呼び出されます。
- onCampaignLoadSuccess, onCampaignLoadFail：キャンペーンサーバーから読み取ったキャンペーン情報のパージング結果を表示します。ゲームでは、このCallbackにおいて特別な処理をする必要はありません。ログ確認のために提供しているCallbackです。

```
private CampaignListener campaignListener = new CampaignListener() {
@Override
public void onCampaignVisibilityChanged(String adSpaceName, boolean show) { ...}
@Override
public void onCampaignLoadSuccess(String adSpaceName) { ...}
@Override
public void onCampaignLoadFail(String adSpaceName, CampaignException exception) { ...}
};
```
###2.ユーザーIDの登録
キャンペーンの実施およびリワードの処理のためには、ユーザーの識別が必須です。キャンペーンはユーザーIDを識別値として用います。したがって、キャンペーン機能を使うためには、ユーザーIDを設定する関数を必ず呼び出す必要があります。
また、この場合に用いられたユーザーIDの値は、ミッション達成時にゲームサーバーからAPIを呼び出すときに送るユーザーIDと同じ値でなければなりません。
ユーザーIDは、ユーザーを識別できるユニークな値で、その長さは50Byte以下の文字列でなければなりません。
``` 
GameAnalytics.setUserId(userId,true); 
```
###3.キャンペーンの表示
onCampaignLoadSuccessの次の段階として、キャンペーンを表示したい場所にキャンペーン表示の関数を呼び出し、ユーザーに一定時間表示します。その後、非表示する関数を呼び出し、キャンペーンポップアップ/バナーを隠します。
次のようなAPIを提供します。
```
showCampaign(String adspaceName, Activity parent);
showCampaign(String adspaceName, Activity parent, int animation, int lifeTime);
hideCampaign(String adspaceName);
hideCampaign(String adspaceName, int animation);
```

###4.リワード情報の処理
キャンペーンがミッション/リワードの情報を含めている場合、ゲームサーバーは、ユーザーがミッションに係わるアクションを行う度にキャンペーンサーバーにミッションの達成有無をチェックします。ミッションの達成が確認されたら、リワード情報はゲームクライアントに送られます。上記の内容は、ゲームサーバーとゲームクライアント間のプロトコールであるため、ゲーム内で直接処理してください。

###5.プッシュの連動
Analytics SDKではキャンペーンのために、GCMを使います。GCMを使うためには、Analytics利用者ページにProject NumberとAPI Keyを登録する必要があります。さらに、SDKにはSenderIDの登録が必要です。
GCMに関する全般的な内容は、Googleが提供する「Google Cloud Message」（http://developer.android.com/google/gcm/gs.html)ドキュメントをご参照ください。
Analytics利用者ページに情報を登録する方法は、「Getting Started」ドキュメントの「プッシュ設定」項目をご参照ください。 
SenderIDは、「setGcmSenderId」APIを通じてSDKに登録できます。
```java
import com.toast.android.analytics.GameAnalytics;
public class TestActivty extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState)
    {
        super.onCreate();
        ……
        int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppID”, “CompanyID”, “AppVersion”, false);
        if(result != GameAnalytics.S_SUCCESS)
            Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));
        }
        GameAnalytics.setGcmSenderId(“123456789012”);
        ……
    } 
```

GCMを使うためには、AndroidManifest.xmlファイルにpermissionとreceiverを追加登録する必要があります。
追加に必要なpermissionは、以下のとおりです。（ここで、「APP.PACKAGE.NAME」は利用者のパッケージ名に変更しなければなりません。)
```xml
<!--  gcmプッシュ権限の設定 -->
<uses-permission android:name="android.permission.GET_ACCOUNTS"></uses-permission>
<uses-permission android:name="android.permission.WAKE_LOCK"></uses-permission>
<uses-permission android:name="com.google.android.c2dm.permission.RECEIVE"></uses-permission>
<uses-permission android:name="android.permission.VIBRATE"></uses-permission>
<permission android:name="APP.PACKAGE.NAME.permission.C2D_MESSAGE" android:protectionLevel="signature"></permission>
<uses-permission android:name="APP.PACKAGE.NAME.permission.C2D_MESSAGE"></uses-permission>
```

追加に登録が必要なReceiverは以下のとおりです。（これも、「APP.PACKAGE.NAME」は利用者のパッケージ名に変更しなければなりません)
```xml
<manifest>
……
<application>
……
<!--  gcmレシーバーの設定 --> 
<receiver android:name="com.toast.android.analytics.gcm.GcmBroadcastReceiver" android:permission="com.google.android.c2dm.permission.SEND">
	<intent-filter android:priority="”1”">
	  <action android:name="com.google.android.c2dm.intent.RECEIVE"></action>
	  <category android:name="APP.PACKAGE.NAME"></category>
	</intent-filter>
</receiver>
<service android:name="com.toast.android.analytics.gcm.GcmIntentService"></service>
……        
</application>
</manifest>
```

サーバーでプッシュ（GCM)メッセージを受信すると、Analytics SDKはNotification Barに通知を表示します。この通知をタッチするとアプリが立ち上がります。 
ここで、何も設定しなければ、そのアプリのMain Activityが表示されます。Main Activity以外のActivityを起動するためには、「setPushIntent」関数を通じて明示的に指定する必要があります。
```java
import com.toast.android.analytics.GameAnalytics;
public class TestActivty extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState)
    {
        super.onCreate();
        ……
        int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppID”, “CompanyID”, “AppVersion”, false);
        if(result != GameAnalytics.S_SUCCESS)
            Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));
        }
        GameAnalytics.setGcmSenderId(“123456789012”);
        ……
        Intent intent = new Intent(getApplicationContext(), GCMActivity.class);
        GameAnalytics.setPushIntent(intent);
        ……
    } 
```

ちなみに、AndroidManifest.xmlにあるActivityのlaunchModeを、singeTop、singleTask、singleInstanceに設定する場合、新しいActivityを作成せず、従来のものを再び使います。
この場合、Push情報が含まれているIntent情報を確実に受け取るためには、そのActivityで「onNewIntent」を明示的にOverrideする必要があります。
```java
public class NEAFlatSampleActivity extends Activity {
    @Override
    protected void onNewIntent(Intent intent)
    {
        super.onNewIntent(intent);
        setIntent(intent);
    }
} 
```

SDKが基本的に提供するGCMプッシュレシーバーを使わず、利用者が直接実装する場合、Manifest設定を以下のように変える必要があります。
また、 GCMプッシュを受け取って処理するロジック（レシーバー、サービス、Notification)も利用者が直接実装しなければなりません。
```xml
<manifest>
……
<application>
……
<!--  gcmreceiverの設定 --> 
<receiver android:name="com.toast.android.analytics.gcm.GcmBroadcastReceiver" android:permission="com.google.android.c2dm.permission.SEND">
<intent-filter android:priority="”1”">
  <action android:name="com.google.android.c2dm.intent.RECEIVE"></action>
  <category android:name="APP.PACKAGE.NAME"></category>
</intent-filter>
</receiver>
<service android:name="com.toast.android.analytics.gcm.GcmIntentService"></service>
……
<!--  gcmpushに関するユーザーの定義における設定 -->
<receiver android:name=".GcmBroadcastReceiver" android:permission="com.google.android.c2dm.permission.SEND">
<intent-filter>
<action android:name="com.google.android.c2dm.intent.RECEIVE"></action>
<category android:name="com.example.aflatgametest"></category>
</intent-filter>
<receiver>
<service android:name=".GcmIntentService"></service>
……
</application>
</manifest>
```

以上のように、SDK用に設定されているレシーバー、サービス設定の下に利用者定義の設定を新たに追加します。
プッシュpayloadを構成する際、「cid」フィールドは、利用者定義プッシュにおいて使ってはなりません。「cid」フィールドは、SDKが提供する基本プッシュにおいて、キャンペーン情報を送信するために内部的に使われているタグです。

###6.Devide IdおよびPush Tokenの確認
本マニュアルの「適用してみよう（ゲーム管理者)」 >「環境設定」 > 「キャンペーン設定」 > 「テストデバイスの設定」を進めるためには、テスト端末のDevice IDおよびPush Token情報が必要です。 
Toast Analytics SDKでは、Device IDおよびPush Tokenの確認のために、プラットフォームごとにAPIを提供しています。このAPIは、initializeSDK後に呼び出さなければなりません。
```
Android
public static String DEVICE_INFO_DEVICEID = "deviceId";
public static String DEVICE_INFO_TOKEN = "token";         
public static String DEVICE_INFO_CAMPAIGN_USERID = "campaignUserId";
public static String getDeviceInfo(String key)
iOS
#define DEVICE_INFO_DEVICEID (@"deviceId")
#define DEVICE_INFO_TOKEN (@"token")
#define DEVICE_INFO_CAMPAIGN_USERID (@"campaignUserId")
+(NSString*)deviceInfoWithKey:(NSString*)key
Unity
public const string DEVICE_INFO_DEVICEID = "deviceId";
public const string DEVICE_INFO_TOKEN = "token";         
public const string DEVICE_INFO_CAMPAIGN_USERID = "campaignUserId";
public static string getDeviceInfo(string key)
Cocos2d-x
#define DEVICE_INFO_DEVICEID_STR ("deviceId")
#define DEVICE_INFO_TOKEN_STR ("token")
#define DEVICE_INFO_CAMPAIGN_USERID_STR ("campaignUserId")
std::string getDeviceInfo(std::string key) 
```

以下は、AndroidにおけるDevice IDおよびPush Tokenの出力に必要なコードです。 
```
// Device IDを呼び出します。
String deviceId = GameAnalytics.getDeviceInfo(GameAnalytics.DEVICE_INFO_DEVICEID);
// Push Tokenを呼び出します。
String pushToken = GameAnalytics.getDeviceInfo(GameAnalytics.DEVICE_INFO_TOKEN);
// 呼び出し済みのDevice IDおよびPush TokenをLogcatコンソールに出力します。
Log.d(“Sample”, “Device ID : “ + deviceId);
Log.d(“Sample”, “Push Token : “ + pushToken); 
```

ログ確認のために、AndroidはLogcatを、iOSはiPhone Configuratorを使います。
![Project Sett](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics_JA/master/docs/Developer/images/image005.png)
[図3 コンソールのログに出力されたデバイスIDおよびプッシュトークン]

Device IDおよびPush Tokenの出力コードは、テスト時にのみ使うことを推奨します。実際外部に提供するビルドからは削除してください。 

##ゲームサーバー

###1.ゲームサーバーの認証
キャンペーンサーバーへのアクセスにおける制限ポリシーがACLから他の方式に変更される予定です。 
現在は、外部からの流入についてACLによる制限を設けていません。
今後、認証関連ポリシーが決まった場合、追加作業が必要となる可能性もあります。

###2.リワードの処理
キャンペーンに関するゲームサーバーの主な作業はリワードの処理です。
ゲームサーバーは、次のような場合に対し、キャンペーンサーバーでcheck-mission APIを呼び出し、ミッションの達成有無を確認する必要があります。
- キャンペーンが進行中の場合、 ミッション設定に関するFactor（Level、Ranking、ゲームプレイ回数など、ゲームで指定した値)に変化がある場合

キャンペーンサーバーにcheck-mission APIを呼び出した際、リワードがある場合には、リワードコードが送られます。その場合、ゲームクライアントにリワードを送信します。上記の処理はゲームで実装されます。(レスポンスデータのrewardListフィールドによりリワード情報が送信されます。（1回のみ)
注意：リワードがない場合も、rewardListフィールドは送信されます。（null値) 

ゲームサーバーの呼び出すミッション達成の通知APIフォーマットは次のとおりです。

###3.リクエストの例
```json
Host:https://api-campaign-analytics.cloud.toast.com
POST /campaign/v1/server/check-mission
Content-Type:application/json
{
    "header":
    {
	    "transactionId" : 92348729384729,
    },
    "userId" : "23948234",
    "appId" : "13",
    "missionKey" : "LEVEL",
    "missionValue" : 10
}
```

###4.リクエスト・パラメータ
リクエスト・パラメータ

|名前|資料のタイプ|説明|
|---|---|---|
|transactionId|	int64|	リクエストの追跡のためにロギング時に用いられますが、必須値ではありません。ここに入力された値は、レスポンスデータのtransactionIdフィールドに適用され、返却されます。
|userId|	string|	ゲームで提供されるunique ID|
|appId|	string|　アプリ登録時に割り当てられたアプリ番号。Analyticsサイトの「アプリ設定」> 「AppKey」の値を入力してください。|
|missionKey|	string|	特定のアクションを定義するKeyまたはonMissionComplete（SDK)を通じて送られた値。Analytics サイトの「アプリ設定」> [キャンペーン設定]> [ミッションおよびリワードアイテムの設定」で登録したミッションのkey|
|missionValue|	int64|	missionKeyに対するValue|

###5.レスポンスの例
```json
HTTP/1.1 200 OK
{
    "header" :
    {
        "transactionId" : 92348729384729,
        "isSuccessful" : "false",
        "resultcode" : 9001,
        "resultMessages" : ["Invalid input parameter.", "..."],
        "serviceCode" : 10
    },
    "rewardList" : [
        {
            "campaignId" : 7,
            "promoDateBegin" : "2014-10-10 00:00:00",
            "promoDateEnd" : "2014-10-11 00:00:00",
            "rewardDateBegin" : "2014-10-10 00:00:00",
            "rewardDateEnd" : "2014-10-12 00:00:00",
            "rewardCode" : "gem",
            "rewardValue" : 100
        },
        ...
    ]
}
```

###6.レスポンスデータ
レスポンスデータ

|名前|資料のタイプ|説明|
|---|---|---|
|transactionId	|int64|	リクエスト時に送られたtransactionIdに同じ設定を適用する。|
|isSuccessful	|string|	成功可否を設定する。（成功:"true", 失敗:"false")|
|resultCode	|int|	リターンコードを作成する。（成功した場合 0)|
|resultMessages	|vector<string>|	複数のリターンメッセージを作成する。|
|serviceCode	|int|	サービスコード|
|campaignId	|int|	リワードのあるキャンペーンの番号|
|promoDateBegin	|string|	キャンペーンの開始時刻（UTC+0を基準とする)|
|promoDateEnd	|string|	キャンペーンの終了時刻（UTC+0を基準とする)|
|rewardDateBegin	|string|	リワードの開始時刻（UTC+0を基準とする)|
|rewardDateEnd	|string|	リワードの終了時刻（UTC+0を基準とする)|
|rewardCode	|string|	リワードコード|
|rewardValue	|int|	リワードの値|