#はじめに

このドキュメントは、UnityでAnalytics SDKを連動するための方法について説明します。Analytics SDKを使うためには、まずアプリを登録する必要があります。アプリの登録方法は、リンク（<http://cloud.toast.com/documents/2/>）をご参照ください。   
* このドキュメントは、Unity4基準で作成されました。   
* Unityプラグイン機能はProバージョンでのみ対応します。つまり、SDK Pluginを使うためには、Unity Proバージョンを使用してアプリケーションを開発する必要があります。   
* Android Manifestの設定、iOS Buildの設定などは、各OS別に提供されるProgramming Guideで説明します。   
* キャンペーン連動に関する内容は、別のドキュメントを提供します。このドキュメントでは、クライアントの実装のみを説明します。全体的な内容は「キャンペーン連動ガイド」をご参照ください。   


#プロジェクトの設定

##SDKダウンロード

SDKは「<http://cloud.toast.com/documents/6/>」でダウンロードできます。

##SDKの構成

ダウンロード後に圧縮を解凍すれば、Unity Packageファイルと変更内容を記録したREADME.txtファイルがあります。

```
	Analytics-SDK-Unity /
  - GameAnalyticsUnityPlugin.unitypackage 	// Analytics SDK Unity Package
  - README.txt                     // Release History
```

##プロジェクトの設定

####1. プロジェクトの作成
Unity3Dを起動し、新しいプロジェクトを作成します。すでに作成したプロジェクトがあれば、この段階は省略します。

![図1 プロジェクトの作成](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics_JA/master/docs/Developer/images/pg_unity_001.png)

[図1 プロジェクトの作成]

####2. ライブラリの追加
Unity3DのMenuからAssets > Import Package > Custom Packageを選択し、ダウンロードしたユニティーパッケージファイルをImportします。

（google-play-services.jar, AndroidManifest.xmlファイルは、ゲームで使うバージョンや他ライブラリに含まれている場合は、追加しなくてもいいです。「res」フォルダの下位にある内容も、google-play-services.jarと一緒に削除できます。）

![図2 ライブラリの追加](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics_JA/master/docs/Developer/images/pg_unity_002.png)

[図2 ライブラリの追加]

####3. Game Objectの作成
空のゲームオブジェクトを作成し、GameAnalyticsUnityPluginControllerをゲームオブジェクトのコンポネントとして追加します。

![図3 Game Objectの作成](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics_JA/master/docs/Developer/images/pg_unity_003.png)

[図3 Game Objectの作成]

####4. SDKを使う
それからゲームで適切なタイミングでアクション追跡APIを呼び出します。<br />
アクション追跡APIは、GameAnalytics.csに定義されています。

####5. OSの追加設定
OS（Android, iOS）別にプロジェクト設定およびManifestに追加で設定しなければならない項目があります。<br / >
詳細は、各OS別に提供されるProgramming Guideのプロジェクト設定項目をご参照ください。



#必須連動
基本的な統計データの収集のために、必ず連動させる必要があるAPIです。必須連動項目のみを実装することで、ほとんどのデータが確認できます。

必須連動項目も以下のとおりです。   
* 初期化：initializeSDK   
* セッション追跡：traceActivation, traceDeactivation   
* 購入（In App Purchase）：tracePurchase   
* 通貨獲得/使用：traceMoneyAcquisition, traceMoneyConsumption   
* レベルアップ：traceLevelUp   
* 友だち数：traceFriendCount   


##初期化

SDKを使うためには、アプリ登録後に発行される「アプリ認証key」と「カンパニーID」が必要です。アプリ登録方法は、リンク（<http://cloud.toast.com/documents/2/>）をご参照ください。

![図4 認証キー情報](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics_JA/master/docs/Developer/images/pg_unity_004.png)

[図4 認証キー情報]

GameAnalytics SDKを使うためには、SDK初期化を先に行う必要があります。   
GameAnalytics クラスのinitializeSDK関数は、SDK初期化を行う関数です。この関数は内部で必要なデータ（デバイス情報、アプリ設定情報）を確認し、ログ送信のための環境を設定する作業を行います。

```c#
using UnityEngine;
using System;
using System.Collections.Generic;
using Toast.Analytics;

public class Sample：MonoBehaviour {

    // Use this for initialization
    void Start () {

     ……

     int result = GameAnalytics.initializeSdk ("APPKEY", "COMPANYID", "VERSION", false);

     if (result != 0) {
        // SDK初期化失敗
     }
     ……

     // 初期化後、セッション追跡を始める
     GameAnalytics.traceActivation()
}
```



#ユーザー区分基準の設定
**運営中に、ユーザー区分基準を変更すると、変更前と変更後のデータの関係性がなくなるため、ゲームリリース後は基準を変えてはいけません。**

Analyticsはユーザーを区分する基準として、Advertise IDまたはUser IDが用いられます。ゲームのポリシーに従い、どちらかを選択しなければなりません。両方とも使用することはできません。
Advertise IDを基準として使うのが一般的ですが、ゲームで特別な要求事項がある場合、User IDを基準にすることもできます。
例えば、Advertise IDを使う場合、一つのデバイスで脱会->再登録を行う場合でも、従来と同じユーザーとして集計されます。一方、User IDを使う場合は新規ユーザーとして集計されます。
または、一人のユーザーが二つのデバイスを使う場合、Advertise IDを使えば、それぞれ違うユーザーとして集計される一方、User IDを使う場合は一人のユーザーとして集計されます。
以上の内容を踏まえ、ゲームで基準を定めて使います。
初期化関数（initializeSDK）の最後の引数（use logging userid flag）により、この値を設定することができます。Flagがtrueの場合、User IDをユーザー区分基準として使います。Falseに設定すると、Advertise IDがその基準になります。

以下のコードは、User IDをユーザー区分基準として使う場合です。

```c#
using UnityEngine;
using System;
using System.Collections.Generic;
using Toast.Analytics;

public class Sample：MonoBehaviour {

    // Use this for initialization
    void Start () {

     ……
     // User IDをユーザー区分基準として使う場合、初期化
     int result = GameAnalytics.initializeSdk ("APPKEY", "COMPANYID", "VERSION", true);

     if (result != 0) {
        // SDK初期化に失敗
     }
     ……
     //ゲームでログイン処理完了
     ……
     //User IDをユーザー区分基準として使う場合、User IDを登録する関数
     GameAnalytics.setUserId(“user_id”, true);
     ……

     //セッション追跡を開始
     GameAnalytics.traceActivation()
}
```

もし、初期化関数の最後の引数（use logging userid flag）をtrueに設定した場合、setUserIdを呼び出し、User IDを登録する必要があります。Flagをtrueに設定し、setUserIdを呼び出さない場合、それ以降呼び出す全てのAPIが失敗（E_LOGGING_USER_ID_EMPTY）をReturnします。

setUserIdの二つ目の引数はPromotionやCampaignを使う場合はtrueです。そうでない場合は、falseです。
setUserId関数は、initializeSDKの呼び出し後、ログイン完了後にゲームで使うuserIDを獲得した直後に呼び出せます。userIDはゲームでユーザーを区分するために使う値を用いることができます。
Advertise IDに関する内容は、以下のリンクをご参照ください。

- Android：<https://developer.android.com/google/play-services/id.html>   
- iOS：<https://developer.apple.com/LIBRARY/ios/documentation/AdSupport/Reference/ASIdentifierManager_Ref/>


##セッション追跡

DAU（Daily Active User）とゲーム滞在時間を追跡するためのものです。 
App開始/終了、Background/Foregroundの移動時にそのアクションに合うAPIを呼び出して測定することができます。
Appの初回起動の際（initializeSDK後）、またはbackgroundからforegroundへの移動の際にtraceActivationを呼び出してセッション追跡を始めます。その後、Appがbackgroundに入るタイミングでtraceDeactivationを呼び出し、セッション追跡を終了します。
traceDeactivationを呼び出すと、traceActivationとtraceDeactivationの間の時間を計算し、ゲーム利用時間を測定します。また、SDKの内部で行った作業もtraceDeactivationにより中止されます。
Background/Foregroundの移動の際、上記の関数を呼び出さないと、ゲーム利用時間を正確に測定することができないため、このAPIは必ず呼び出さなければなりません。
DAUは一日にtraceActivationを呼び出したユーザー（Advertise IDまたはUser ID基準）の重複を除いた数値で計算されます。

```c#
void OnApplicationPause(bool paused) {

    if(paused) {
    	GameAnalytics.traceDeactivation();
    } else {
        GameAnalytics.traceActivation();
    }
    
}
```

##アクション追跡

In-App Purchase、通貨獲得/使用、レベルアップ、友だち数の変更など、ユーザーのActionに対して追跡できます。

####1. In-App Purchase
In-App Purchaseの発生後、tracePurchaseを呼び出し、売上情報を送信します。
Currencyは、ISO-4217(<http://en.wikipedia.org/wiki/ISO_4217>)で定義したコードを使います。
$0.99の宝石を購入する場合、次のようになります。
（ここで、「GEM_10」は、ゲームに定義されているItemのCodeです。Unit Costは、そのアイテムの単位価格、Paymentは実際にユーザーが使った金額です。Levelは購入したユーザーのLevelを入力します。）

```c#
GameAnalytics.tracePurchase("GEM_10", 0.99f, 0.99f, "USD", 10);
```
	
####2. 通貨獲得/使用
ゲーム内の通貨の獲得/使用時に呼び出します。1次通貨、2次通貨の変動量を追跡します。一般的に、1次通貨はIn-App Purchaseを通じて購入する通貨（ex. 宝石、ルビーなど）です。2次通貨は、1次通貨を利用して購入する通貨（ex. チェリー、ハートなど）です。
IAPを通じて宝石10個を購入した場合、以下のように使います。
（「CODE_IAP」は、ゲームに定義されているCodeです。1次通貨の場合、Typeは0、2次通貨の場合は1を使います。）

```c#
GameAnalytics.traceMoneyAcquisition("CODE_IAP", "0", 10, 10);
```
	
宝石10個でチェリーを100個購入した場合は、次のようになります。

```c#
// 1次通貨の使用
GameAnalytics.traceMoneyConsumption("CODE_USE_GEM", "0", 10, 10);

// 2次通貨の獲得
GameAnalytics.traceMoneyAcquisition("CODE_BUY_CHERRY", "1", 100, 10);
```

1次通貨を使って2次通貨を購入した場合、「1次通貨の減少」->「2次通貨の増加」が発生します。しかし、2次通貨を購入する際、1次通貨を使うケースを通貨減少として捉えたくないなら、「2次通貨獲得」ログのみの送信でも構いません。

####3. レベルアップ
ユーザーレベルが変更される場合、traceLevelUpを呼び出します。ちなみに、ほとんどのアクション追跡APIは、レベルごとにアクションを追跡するためにユーザーLevelも一緒に受け取ります。
ユーザーレベルが10に変更される場合、以下のように呼び出します。一人のユーザーのレベルは、必ず上がらなければなりません。レベルが下がるとデータを正確に測定することができません。
例えば、「Candy Crush Sage」のようなステージ型のゲームで、ステージをレベルとして捉えます。このような場合は、ステージへの初回アクセスのみレベルアップログを記録します。もし、前のステージに戻ってプレイし直す場合、レベルアップログは残しません。
また、他のAPIに送信されるlevel値も、現在プレイしているステージではなく、ユーザーの最高ステージをレベル値として使う必要があります。
```c#
GameAnalytics.traceLevelUp(10);
```
	
####4. 友だち
ユーザーの友だちの数を登録します。一般的にアプリの起動後、友だち情報の読み込みが全て完了したタイミングで呼び出します。
```c#
GameAnalytics.traceFriendCount(100);
```


	
#選択的連動
基本連動により提供される基本指標のほかに、ゲームでさらに測定したい指標がある場合、またはAnalyticsから提供されるCampaign機能を使う場合の方法について説明します。

追加連動が可能な項目は以下のとおりです。
- Campaign連動：setCampaignListener, (show/hide)Campaign   
- Custom Eventの収集：traceEvent   
- プロモーション連動：isPromotionAvailable, getPromotionButtonImagePath, launchPromotionPage   
- 所用時間の測定：traceStartSpeed, traceEndSpeed   

##キャンペーンの連動

####1. キャンペーン連動のための事前準備
キャンペーン連動および実施に関するガイドを別途提供しています。
Toast Analyticsの「キャンペーン実施」メニューの「ページガイド」をご参照ください。
（<http://analytics.toast.com/promotion/share/document/4.2_Campaign_run.pdf>）

####2. プッシュの連動
プッシュ連動は、OS別（iOS/Android）にApp Lifecycleに合わせてそれぞれ作成する必要があります。Unityでビルド後に各OS別に作成されるプロジェクトに、該当するコードを追加する必要があります。

Analytics Android SDKが提供する「setGcmSenderId」関数は、Unity Pluginでも提供しています。ただし、この関数を呼び出すと、Androidでのみ動き、iOSでは内部で何も動かず、常に成功をReturnします。

さらに、Androidでプッシュを使用する場合、「android-support-v4.jar」ファイルをプロジェクトに入れてビルドする必要があります。Analytics Unity Pluginに一緒に入れて配信していますが、すでにプロジェクトにそのライブラリが含まれていたり、他のバージョンを使いたい場合は、Pluginに含まれたファイルを削除する必要があります。

iOS Programming GuideとAndroid Programming Guideの「4.1.2プッシュ連動」項目をご参照ください。

####3. キャンペーンListenerの実装および登録
SDKは一定の周期でキャンペーンサーバーと通信し、キャンペーンおよびリワード情報を受け取ります。もし、現在ユーザーが参加できるキャンペーンが行われているか、ユーザーが受け取るリワード情報がある場合、CampaignListenerを通じて知らせます。

したがって、キャンペーン情報を受け取るためには、CampaignListenerを実装する必要があります。

```c#
public interface CampaignListener {
    void OnCampaignVisibilityChanged(string adspaceName, bool show);
    void OnCampaignLoadSuccess(string adspaceName);
    void OnCampaignLoadFail(string adspaceName, int errorCode, string errorMessage);
    void OnMissionComplete(List<string> missionList);
    void OnCampaignClick(string callbackInfo);
    void OnPromotionVisibilityChanged(bool show);
}
```

各Callbackは、以下のような場合に呼び出されます。

- OnCampaignVisibilityChanged：showCampaign、hideCampaignを呼び出し、キャンペーンに関するポップアップやバナーの表示/非表示の際に呼び出されます。   
- OnMissionComplete：ユーザーがキャンペーンおよびプロモーションに参加し、特定のミッションを達成してリワード情報がある場合に呼び出されます。ここで受け取った情報を利用し、ゲームサーバーを通じてリワードを付与する必要があります。キャンペーンのリワードに関するプロセスは、「キャンペーン適用ガイド」をご参照ください。   
- OnCampaignLoadSuccess、OnCampaignLoadFail：サーバーから受け取ったキャンペーン情報のパージング結果を表示します。ゲームではこのCallbackで特別な処理をする必要はありません。ログ確認のために提供するCallbackです。
- OnCampaignClick : リンクタイプをDeeplinkに選択した場合、登録した文字列を送信するCallbackです。ここから送られた文字列を参考し、ゲーム内の動作を処理します。
- OnPromotionVisibilityChanged：Promotionを使う場合、Promotion Viewの表示/非表示の際に呼び出されます.   

実装したCampaignListenerは、setCampaignListenerを使って登録します。
```c#
function setListener() {
    ……
    GameAnalytics.setCampaignListener(new MyCampaignListener());
    ……
}

public class MyCampaignListener：CampaignListener
{
    public void OnCampaignVisibilityChanged(string adspaceName, bool show)
    {
      ……
    }

    public void OnCampaignLoadSuccess(string adspaceName)
    {
      // for Debugging
    }

    public void OnCampaignLoadFail(string adspaceName, int errorCode, string errorMessage)
    {
      // for Debugging
    }

    public void OnMissionComplete(List<string> missionList)
    {
      // missionList Stringにはkey/value情報が区切り文字「|」で提供されます.
      // この値に基づいてゲームサーバーを通じてpromotion serverで検証を行い、ユーザーに
      // リワードを付与します。
    }
    
    void OnCampaignClick(string callbackInfo)
    {
      // リンクタイプをDeeplinkに選択した場合、登録した文字列を送信するCallbackです。
      // ここから送られた文字列を参考し、ゲーム内の動作を処理します。
    }
    
    public void OnPromotionVisibilityChanged(bool show)
    {
      // Promotion Viewのオープンの際、showがtrueに送信されます。
      // showがtrueの場合、ゲームのレンダリング性能を低減する作業が行えます。
      // 一方、showがfalseの場合、ゲームのレンダリング性能を元に戻せます。
    }

}
```

####4. キャンペーンShow/Hide

現在利用者に実施しているキャンペーンがある場合、Analyticsウェブサイトに登録済みのキャンペーンポップアップ/バナーを表示し、表示されたポップアップ/バナーを隠すメソッドです。adspaceNameパラメータは、Analyticsウェブサイトでキャンペーン登録時に定義したadspaceの名前を使います。Adspaceとは、ポップアップ/バナーが表示されるゲーム内の特定場所を意味します。

showCampaign()メソッドは、該当するadspaceを使うキャンペーンがなければ動かないため、キャンペーンポップアップ/バナーを表示すると予想されるゲーム内の複数のポイントに、それぞれ違うadspaceNameで関数を呼び出しておくと、それ以降のポップアップ/バナーの表示は、別のゲームクライアントの修正無しでゲームの利用者がAnalyticsウェブサイトにキャンペーンを登録する作業だけで可能になります。

Adspaceの登録方法は、「キャンペーンテストガイド」をご参照ください。
```c#
public static int showCampaign(string adspaceName)
public static int showCampaign(string adspaceName, AnimationType animation, int lifeTime) 
public static int hideCampaign(string adspaceName) 
public static int hideCampaign(string adspaceName, AnimationType animation) 
```


##カスタマイズイベント使用

ゲームごとに特定イベントを定義し、分析したい場合に使います。

例えば、Fever Time Itemを使う場合、次のようになります。使われた全てのコードは、ゲームで定義して使います。以下の例題は、特定ステージにおけるアイテム変動を追跡するために定義したコードです。
```c#
GameAnalytics.traceEvent("ITEM", "ITEM_USE", "FEVER", "STAGE_10", 1, 10);
```
	
特定レベルにおけるボスバトルの結果を追跡する時も使います。
```c#
GameAnalytics.traceEvent("STAGE", "STAGE_BOSS_VICTORY", "DRAGON_VALLEY", "BOSS_MOB", 1, 10);
```
	
そのほかにも、様々な形でゲームに特化したイベントの追跡に使います。

traceEventに使用するString Typeパラメータ（event type, event code, param1, param2）は、それぞれ50byteまで使うことができます。そして、event下位に作成可能なparam1は300まで、さらにparam1の下位に作成可能なparam2は200まで使うことができます。

Event Codeは、必ずUniqueである必要があります。Event Typeが異なっても、同じEvent codeの場合、指標がSumされ、紹介されますので、実装時には注意してください。

詳細はToast Analyticsサイトのガイドをご参照ください（カスタマイズイベントページの右上にある「ページガイド」クリックすれば、ダウンロードできます）。


##プロモーション連動

ゲームで他のゲームとプロモーション連動を行う場合に使います（この機能は、現在アンドロイドでのみ動きます）。

####1. プロモーション連動のための事前準備
プロモーション連動および実施に関するガイドを、別途提供しています。

####2. プロモーションボタンの追加
Analytics設定ページでプロモーション情報を登録してから、ボタン画像を登録すれば、SDKの初期化の際、ボタンをダウンロードしてDeviceに保存します。

ゲームではボタン画像を利用し、適切な場所にボタンを作成しなければなりません。

ボタンを作成する前に、まずプロモーションが可能な状態かを確認します。利用者がAnalyticsのウェブページでプロモーションを使わないと設定している場合、ボタン画像のダウンロードに失敗した場合、またはプロモーションサービスのメンテナンスや障害が発生した場合には、プロモーション実施が不可能なため、ボタンを画面に表示してはいけません。

「isPromotionAvailable()」でプロモーションの実施可否を確認することができます。プロモーション実施が可能な状態であれば、「getPromotionButtonImagePath()」関数を利用し、ボタン画像のパスを確認して、ゲームで適切な場所にボタンを作成します（ボタン画像はPNGタイプで保存します）。

（Analytics設定に登録した画像を使わず、ゲーム配信パッケージに含まれている画像を使ってボタンを作成することも可能です。ただし、この場合も、プロモーションの実施可否を必ず確認-isPromotionAvailable-した後、ボタンを作成する必要があります。）
```c#
if (GameAnalytics.isPromotionAvailable() == true) {
    Debug.Log ("Show Toast Promotion Button");
    string buttonImagePath = GameAnalytics.getPromotionButtonImagePath();
    if (File.Exists(buttonImagePath)) {
        byte[] imageData = File.ReadAllBytes(buttonImagePath);
        ……
    }
    ……
} else {
    Debug.Log ("Hide Toast Promotion Button");
}
```

####3. プロモーションの実施
プロモーションボタンをタッチする場合、「launchPromotionPage()」を呼び出し、プロモーションを実施します。

（プロモーションのリワード付与有無を確認するためにユーザーIDを使います。 launchPromotionPageを呼び出す前にsetUserIdを呼び出し、ユーザーIDを入力する必要があります。プロモーションを使う状況であるため、setUserIdの2番目の引数を「true」に設定します。）
```c#
private void touchPromotionButton() {
    ……
    GameAnalytics.launchPromotionPage();
    ……
}
```
	
「launchPromotionPage()」では、内部的にWebViewを使い、プロモーションコンテンツを提供します。この機能を使うためには、AndroidManifet.xml設定に該当するActivityを追加する必要があります。

Promotion Viewが実行されてから消える際、「OnPromotionVisibilityChanged」callbackが呼び出されます。このcallbackにより、ゲームでのレンダリングを中止したり開始したりすることができます。

横/縦画面を固定させるためには、android:screenOrientationを利用すると設定できます。

(<http://developer.android.com/guide/topics/manifest/activity-element.html#screen>)
```xml
<activity 
    android:configChanges="keyboard|keyboardHidden|orientation|
        screenLayout|uiMode|screenSize|smallestScreenSize"
    android:name="com.toast.android.analytics.PromotionActivity" />
```

さらに、アプリインストール/起動時に広告効果を測定するために、Install Receiverを登録する必要があります。

Install Receiverはプロモーションを通じてアプリをインストールした場合（Google Playのみ可能）、効果測定のために必要です。Execution Receiverは、アプリがインストールされている場合、プロモーションを通じて実施効果を測定するために必要です。
```xml
<receiver android:name="com.toast.android.analytics.InstallReferrerReceiver" android:exported="true">
    <intent-filter>
        <action android:name="com.android.vending.INSTALL_REFERRER"/>
    </intent-filter>
</receiver>

<receiver android:name="com.toast.android.analytics.ExecutionReferrerReceiver" android:exported="true">
    <intent-filter>
        <action android:name="com.toast.android.analytics.toastpromotion.EXECUTION" />
    </intent-filter>
</receiver>
```

多数のInstall Receiverを使う場合の設定方法は、「Android Programming Guide」の「2.2.2. AndroidManifes設定」をご参照ください。

（同じActionを処理するBroadcast Receiverは、アプリ内で一つだけを登録することができます。他のSDKでもInstall Referrerを使用する場合、必ず「Android Programming Guide」で複数のInstall Receiverを登録するガイドをご参照ください。）

####4. リワード
ユーザーにプロモーションページが表示されている場合、リワードを付与します。さらに、プロモーションを通じてアプリをインストールしたり、特定のミッションを達成した場合にもリワードを付与します。

リワードに関する情報は、「CampaignListener」の「onMissionComplete」を通じて送信されます。

リワード処理の手続きは、「プロモーションの適用および運営ガイド」ドキュメントをご参照ください。


##所用時間の測定

特定区間における所要時間が測定できます。例えば、チュートリアルの所要時間やSceneの切替にかかる時間を測定したい場合など、時間の測定が必要な任意区間で使用できます。

Intro Sceneを読み込む時間を測定したい場合、以下のように使います。「INTRO_LOADING」は、特定区間に対し、ゲームで定義する値です。
```c#
void onStart() {
    GameAnalytics.traceStartSpeed("INTRO_LOADING");
}

void onLoadCompleted() {
    GameAnalytics.traceEndSpeed("INTRO_LOADING");
}
```

##Facebookインストール追跡

Facebook広告を通じたアプリインストールを追跡できます。本機能は、Facebookで提供しているDeep Linking機能を参照します。上記に関する詳細及びテスト方法は、Facebook提供のドキュメント（https://developers.facebook.com/docs/app-ads/deep-linking）を参考にしてください。FB.Mobile.FetchDeferredAppLinkDataは、Facebook SDKで提供しているAPIです。
(https://developers.facebook.com/docs/unity/reference/current/FB.Mobile.FetchDeferredAppLinkData)

```c#
FB.Mobile.FetchDeferredAppLinkData(DeepLinkCallback);

void DeepLinkCallback(IAppLinkResult result) {
    if(!String.IsNullOrEmpty(result.Url)) {
        GameAnalytics.traceFacebookInstall(result.Url);
    }
}
```

#SDKの設定

####1. デバッグモードの有効化
開発中にSDKログを確認するため、ログの出力有無を設定することができます。

この関数は、initializeSDK以前/以降、どちらも呼び出し可能です。デフォルト値は、setDebugMode(false)です。

（アンドロイドではlog tagが「Analytics:」から始まります。Eclipseでlog cat filterを「Analytics」に指定すれば、SDKで発生するログを確認することができます。）
```c#
void Start () {
     … …
     GameAnalytics.setDebugMode(true);
     … …

     int result = GameAnalytics.initializeSdk ("APPKEY", "COMPANYID", "VERSION", false);

     if (result != 0) {
        // SDK初期化失敗
     }
     … …
}
```

デバッグモードが有効になった場合、ログ送信内容を確認することができます。ログを送信し、それに対するレスポンスログを確認することで、ログが正常に送信されたかが確認できます。収集済みのデータのサーバーへの送信が正常終了すると、以下のようなログ文字列が表示されます（\*\*\*は、場合によって違う値になります）。
```
Android：server response (***)：200 OK
iOS：RequestWorkerThread::didReceiveResponse - <NSHTTPURLResponse: ***> { URL: *** } { status code: 200002C
```

####2. デバイス情報の確認
SDKに収集されるDevice情報を確認することができます。

現在確認できる値は、Device ID、Push User ID、Campaign User IDです。これらの値は、キャンペーン連動テストの際に必要です。詳細は、「キャンペーン連動ガイド」をご参照ください。

Device情報を確認するために使うKeyです。

- public static final String DEVICE_INFO_DEVICEID = “deviceId”;
- public static final String DEVICE_INFO_PUSH_USERID = “pushUserId”;
- public static final String DEVICE_INFO_CAMPAIGN_USERID = ”campaignUserId”;

```
void printDeviceInfo() {
     string deviceID = GameAnalytics.getDeviceInfo(GameAnalytics.DEVICE_INFO_DEVICEID);
     string pushUserID = GameAnalytics.getDeviceInfo(GameAnalytics.DEVICE_INFO_PUSH_USERID);
     string campaignUserID = GameAnalytics.getDeviceInfo(GameAnalytics.DEVICE_INFO_CAMPAIGN_USERID);
     … …
}
```
	
####3. SDKバージョンの確認
SDKバージョンは、「PluginVersion」classで確認することができます。
```
namespace Toast.Analytics 
{
    public class PluginVersion 
    {
        public const int VersionInt = 0x0100;
        public const string VersionString = "0.1.00";
    }
}
```



#APIのReference

##SDKのAPI List

Analytics SDKは、表01と同じAPIを提供します。各APIに対する詳細説明は、表02をご参照下さい。

[表01クライアントSDKのAPIリスト]

|API|説明|
|---|---|
|setDebugMode|デバッグメッセージをデバッグコンソールに表示します。リリースバージョンの場合、必ずfalseにセットします。|
|initializeSdk|クライアントSDKモジュールを初期化します。|
|setCampaignListener|Campaign表示状態が非同期的に通知されるリスナーを登録します。|
|setUserId|initializeSdkで「useLoggingUserId=true」に設定した場合、ユーザーを区分するIDを入力します。|
|showCampaign|該当するCampaignビューの表示をリクエストします。関連リソースが準備されていない場合、準備されるまで表示が遅れ、表示時にsetOnCampaignListenerに登録したリスナーを通じて通知を受けることができます。|
|hideCampaign|該当するCampaignビューを隠します。|
|traceActivation|アプリがフォアグラウンドに切り替わる時に呼び出します。|
|traceDeactivation|アプリがバックグラウンドに戻る際に呼び出します。|
|tracePurchase|アプリ内でアイテムを購入した時に呼び出します。|
|traceMoneyAcquisition|通貨を獲得した時に呼び出します。|
|traceMoneyConsumption|通貨を消費した時に呼び出します。|
|traceLevelUp|レベルアップした時に呼び出します。|
|traceEvent|利用者定義のイベントが発生した時に呼び出します。|
|traceFriendCount|友だちの数を設定します。|
|traceStartSpeed|特定区間の所要時間を測定しようとする時に、開始タイミングで呼び出します。|
|traceEndSpeed|特定区間の所要時間を測定しようとする時に、終了タイミングで呼び出します。|
|getVersion|SDKバージョンを出力します。|
|getDeviceInfo|デバイスID、プッシュトークン、キャンペーンユーザーID情報を出力します。|
|isPromotionAvaliable|プロモーションが行われているかを確認します（Android）。|
|getPromotionButtonImagePath|プロモーションに入るためのボタン画像のパスです。Analytics Webで登録したボタン画像を、SDKでダウンロードし、app cacheパスに保存します。（/data/data/[package name]/cache/[filename]）（Android）|
|getPromotionButtonImagePath|プロモーションページを起動します（Android）。|

[表02クライアントSDKの共通Return Value]

|Return Value|値|説明|
|---|---|---|
|S_SUCCESS|0x0000|成功|
|W_ALREADY_INITIALIZED|0x1000|SDKがすでに初期化されました。|
|E_NOT_INITIALIZED|0x8000|SDKが初期化されなかった状態でapiが呼び出されました。|
|E_SESSION_CLOSED|0x8001|traceStartが呼び出されなかった状態でapiが呼び出されました。|
|E_INVALID_PARAMS|0x8002|有効ではない引数値が送信されました。|
|E_ALREADY_EXISTS|0x8003|同じscreenCode値でtraceStartSpeedが2回以上呼び出されました」。|
|E_INTERNAL_ERROR|0x8004|内部エラー|
|E_INSUFFICIENT_OPERATION|0x8005|traceStartSpeedが呼び出されていないscreenCode値でtraceEndSpeedが呼び出されました。|
|E_APP_ID_IS_EMPTY|0x8006|SDK初期化時に必須入力値であるアプリIDの値がNULL。|
|E_ENTERPRISE_ID_IS_EMPTY|0x8007|SDK初期化時に必須入力値であるEnterprise IDの値がNULL。|
|E_APP_VERSION_IS_EMPTY|0x8008|SDK初期化時に必須入力値であるアプリバージョンの値がNULL。|
|E_TOKEN_EMPTY|0x8009|デバイストークンの値がNULL。|
|E_ACTIVITY_EMPTY|0x800A|アクティビティの値がNULL。|
|E_LOGGING_USER_ID_EMPTY|0x800B|Analytics用ユーザーIDの値がNULL。|
|E_MANIFEST_APPSTORE_MISSING|0x800C|AndroidManifest.xmlメータデータのうち、com.nhnent.aflat.appstore値が存在しません。|
|E_CAMPAIGN_SHOW_EXPIRED|0x7000|満了期間が過ぎたキャンペーンに対してリクエストします。|
|E_CAMPAIGN_SHOW_ALREADY|0x7001|すでに表示したキャンペーンビューをshowリクエストしたり、表示またはQueueingされていないキャンペーンビューをhideリクエストします。|
|E_CAMPAIGN_SHOW_PENDING|0x7002|すでに他のキャンペーンビューが表示されていて、キャンペーンビューshowリクエストがQueueingされました。|
|E_CAMPAIGN_SHOW_FAIL|0x7034|キャンペーンビューのリソースのうち一部をロードすることができません。|
|E_CAMPAIGN_SHOW_BLOCKED|0x7004|キャンペーン表示がユーザーによってブロックされたか、すでに実施済みのキャンペーンです。|
|E_CAMPAIGN_NOTEXIST|0x7005|キャンペーンが存在しません。|
|E_CAMPAIGN_DISABLED|0x7006|デバイスでキャンペーンがdisableになりました。|
|E_CAMPAIGN_USER_ID_IS_EMPTY|0x7007|キャンペーン実行用ユーザーIDの値が設定されていません。|

