#はじめに

このドキュメントは、AndroidでAnalytics SDKを連動するための方法について説明します。Analytics SDKを使うためには、まずアプリを登録する必要があります。アプリの登録方法は、リンク（<http://toastanalytics.readthedocs.io/ja/latest/Developer/1.%20Getting%20Started/#_4>）をご参照ください。

**キャンペーン連動に関する内容は、別のドキュメントを提供します。このドキュメントでは、クライアント実装のみを説明します。全体的な内容については、「キャンペーン連動ガイド」をご参照ください。**


#プロジェクト設定


##SDKのダウンロード

1. Analytics SDKのダウンロード
    <http://docs.cloud.toast.com/ko/Download/>　からAndroid SDKファイルをダウンロードします。
2. グーグルサービスAPIのダウンロード
    Analytics SDKではAdvertising IDを使うために、Google Player Serviceが必要です。
    アンドロイドSDK Managerを利用し、最新バージョンのグーグルプレイサービスAPI（google-play-service.jar）をダウンロードします。
    （<https://developer.android.com/sdk/installing/adding-packages.html>）


##プロジェクト設定

###ライブラリdependencyの設定 (Eclipse)
ダウンロードしたGameAnalyticsSDK_Android_v1.xxx.zipファイルの圧縮を解凍し、以下の図のようにプロジェクトのlibsディレクトリにコピーします（GameAnalytics SDK jarファイル1つと性能/セキュリティ指標収集のためのnative libraryがあります）。

ダウンロードしたグーグルサービスAPIの場合、jarタイプではないアンドロイドライブラリであるため、そのライブラリをイクリプスにimportしてからこそ、利用者プロジェクトで使うことができます。
（<http://developer.android.com/google/play-services/setup.html>）

イクリプスにグーグルサービスAPIをライブラリとしてimportした後、現在作成している利用者プロジェクトのルートフォルダにマウスカーソルを置き、右クリックします。

右クリック後、現れるポップアップで、Propertiesメニューを押し、上図のようにポップアップが表示されたら、ポップアップ左側のメニューにあるAndroidを選んだ後、右側のlibraryで[Add]ボタンを押してグーグルサービスAPIライブラリのパスを指定します。

###ライブラリdependencyの設定 (Android Studio)
ダウンロードしたGameAnalyticsSDK_Android_v1.xxx.zipを解凍すると、ToastAnalyticsSDKというAndroidプロジェクトが作成されます。そのプロジェクトをモジュールで追加してからdependency設定を行ってください。

Android Studioでプロジェクトを作成してから、File - New - Import Moduleメニューを選択します。

![Import Module Step1](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_003.png)

解凍したToastAnalyticsSDK Androidプロジェクトの経路を選択します。

![Import Module Step2](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_004.png)

適切なオプションをチェックしてから、次に進みます。一般的にはデフォルトを使用します。

![Import Module Step3](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_005.png)

モジュールを追加してから、dependencyを設定してください。まず、FileメニューでProject Structureを選択します。

![Project Setting 1](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_006.png)

ToastAnalyticsSDKをModuleで追加したため、Module dependencyを選択します。

![Project Setting 2](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_007.png)

toastAnalyticsSDKを選択してから、dependencyを追加します。

![Project Setting 3](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_008.png)

google play serviceライブラリもdependencyを追加する必要があります。既にプロジェクトにgoogle play serviceが追加されているのであれば、本段階はスキップできます。

![Project Setting 4](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_009.png)

google play service 버전은 환경에따라 다를 수 있습니다. Toast Analytics SDK를 적용하기 위해서는 Google Play Services 7.5 이상 버전이 필요합니다.

![Project Setting 5](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_010.png)

###AndroidManifestの設定
Analytics SDKでは、以下のようなPermissionを使います。


```xml
<!—端末のモデム状態（ex.回線の事業社名）を検索するために使います。 -->
<uses-permission android:name="android.permission.READ_PHONE_STATE"/>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
<uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
<uses-permission android:name="android.permission.INTERNET" />
```

ストア情報は、利用者がアプリをダウンロードしたマーケットに対する情報を追跡するための設定です。現在、使用できるストアは以下の通りです。
(定義されたストア以外の値を使うと、「その他」に分類されます。ストア追加が必要な場合は、管理者にお問い合わせください。)

ストア | 入力文字列 (android:value=)
------------- | -------------
Google Play Store | Google
Apple App Store | Apple
Naver Store | Naver
T-Store | Tstore
One Store | onestore
China AOS-360 | CN_360
China AOS-Baidu | CN_Baidu
China AOS-Xiaomi | CN_Xiaomi
China AOS-UC | CN_UC
China AOS-Bilibili | CN_Bilibili
China AOS-Flyme | CN_Flyme
China AOS-37 | CN_37
China AOS-Otaku | CN_Otaku
China AOS-OPPO | CN_Oppo
China AOS-HUAWEI | CN_Huawei
China AOS-ANZHI | CN_Anzhi
China AOS-WANDOU | CN_Wandou
China AOS-OtakuChannel | CN_OtakuChannel
China AOS-Tencent | CN_Tencent
China AOS-Lenovo | CN_Lenovo
China AOS-Site 直接配布（*マーケットを通さない） | CN_Direct

```xml
<manifest>
    ……
    <application>
        ……
        <!-- ストア情報の設定 -->
        <!-- android:value is Tstore, Olleh, Uplus, NaverApp etc  -->
        <meta-data
            android:name="com.toast.android.analytics.appstore"
            android:value="Google" />
        ……
    </application>
</manifest>
```
    

インストール流入経路を分析するためには、Install Receiver設定が必要です（Google Playを通じてアプリをインストールする場合のみ動きます）。

```xml
<manifest>
    ……
    <application>
        ……
        <receiver
            android:name="com.toast.android.analytics.InstallReferrerReceiver"
            android:exported="true">
            <intent-filter>
                <action android:name="com.android.vending.INSTALL_REFERRER"/>
            </intent-filter>
        </receiver>
        ……
    </application>
</manifest>
```

    
同じActionを処理するBroadcast Receiverは、アプリ内で一つだけ登録できます。複数の箇所でInstall Referrerを使う場合、必ず以下のガイドに沿って設定しなければなりません。

Receiverは一つだけ登録します。但し、meta-dataを利用して他のReceiverを追加することもできます。

Install Receiverの設定が間違った場合、新規ユーザーの集計ができなくなる可能性があります。

他のレシーバーを追加で登録するためには、以下の設定のとおり、meta-dataとして追加します。この場合、android:valueにはそのレシーバーのClass名を書きます。

```xml
<receiver 
    android:name="com.toast.android.analytics.InstallReferrerReceiver" 
    android:exported="true">
    <intent-filter>
        <action android:name="com.android.vending.INSTALL_REFERRER"/>
    </intent-filter>

    <meta-data android:name="forward1" android:value="Receiver-Class-Name" />
    <meta-data android:name="forward2" android:value=" Receiver-Class-Name" />
</receiver>
```
 
#必須連動

基本的な統計データを収集するために、必ず連動しなければならないAPIです。必須連動項目のみを実装することで、ほとんどのデータが閲覧できます。
必須連動項目は、以下のとおりです。

*初期化：initializeSDK
*セッション追跡：traceActivation, traceDeactivation
*課金（In App Purchase）：tracePurchase
*財貨獲得/使用：traceMoneyAcquisition, traceMoneyConsumption
*レベルアップ：traceLevelUp
*友だちの数：traceFriendCount


##初期化

SDKを使うためには、アプリ登録後に発行される「アプリID」と「カンパニーID」が必要です。アプリの登録方法は、リンク（<http://toastanalytics.readthedocs.io/ja/latest/Developer/1.%20Getting%20Started/#_4>）をご参照ください。

initializeSDK関数のAppIDは、アプリ情報の「AppKey」を、CompanyIDは「カンパニーID」を使います。

![App Key](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_002.png)

GameAnalytics SDKを使うためには、SDK初期化が必要です。

GameAnalyticsクラスのinitializeSDKは、SDKの初期化を行う関数です。この関数は、内部で必要なデータ（デバイス情報、アプリ設定情報）を確認し、ログ送信のための環境を設定する作業を行います。


```java
import com.toast.android.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState)
  {
    super.onCreate();
    ……
    int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppKey”, “CompanyID”, “AppVersion”, false);

    if(result != GameAnalytics.S_SUCCESS) {
        Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));
    }

}
```
    
##ユーザー区分基準の設定

**運営中に、ユーザー区分基準を変更すると、変更前と変更後のデータの関係性がなくなるため、ゲームリリース後は基準を変えてはいけません。**

Analyticsはユーザーを区分する基準として、Advertise IDまたはUser IDが用いられます。ゲームのポリシーにしたがい、どちらかを選択しなければなりません。両方とも使用することはできません。

Advertise IDを基準として使うのが一般的ですが、ゲームで特別な要求事項がある場合、User IDを基準にすることもできます。

例えば、Advertise IDを使う場合、一つのデバイスで脱会->再登録を行う場合でも、従来と同じユーザーとして集計されます。一方、User IDを使う場合は新規ユーザーとして集計されます。

または、一人のユーザーが二つのデバイスを使う場合、Advertise IDを使えば、それぞれ違うユーザーとして集計される一方、User IDを使う場合は一人のユーザーとして集計されます。

以上の内容を踏まえ、ゲームで基準を定めて使います。

初期化関数（initializeSDK）の最後の引数（use logging userid flag）により、この値を設定することができます。Flagがtrueの場合、User IDをユーザー区分基準として使います。Falseに設定すると、Advertise IDがその基準になります。

以下のコードは、User IDをユーザー区分基準として使う場合です。

```java
import com.toast.android.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState)
  {
    super.onCreate();
    ……
    int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppID”, “CompanyID”, “AppVersion”, true);

    if(result != GameAnalytics.S_SUCCESS) {
        Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));
    }
    ……
    //ゲームでログイン処理完了
    ……
    //User IDをユーザー区分基準として使う場合、User IDを登録する関数
    GameAnalytics.setUserId(“user_id”, true);
    ……
}
```
    
もし、初期化関数の最後の引数（use logging userid flag）をtrueに設定した場合、setUserIdを呼び出し、User IDを登録する必要があります。Flagをtrueに設定し、setUserIdを呼び出さない場合、それ以降呼び出す全てのAPIが失敗（E_LOGGING_USER_ID_EMPTY）をReturnします。

setUserIdの二つ目の引数はPromotionやCampaignを使う場合はtrueです。そうでない場合は、falseです。

setUserId関数は、initializeSDKの呼び出し後、ログイン完了後にゲームで使うuserIDを獲得した直後に呼び出せます。userIDはゲームでユーザーを区分するために使う値を用いることができます


Advertise IDに関する内容は、以下のリンクをご参照ください。
- Android：<https://developer.android.com/google/play-services/id.html>


##セッション追跡

DAU（Daily Active User）とゲーム滞在時間を追跡するためのものです。 

App開始/終了、Background/Foregroundの移動時にそのアクションに合うAPIを呼び出して測定することができます。 

Appの初回起動の際（initializeSDK後）、またはbackgroundからforegroundへの移動の際にtraceActivationを呼び出してセッション追跡を始めます。その後、Appがbackgroundに入るタイミングでtraceDeactivationを呼び出し、セッション追跡を終了します。 

traceDeactivationを呼び出すと、traceActivationとtraceDeactivationの間の時間を計算し、ゲーム利用時間を測定します。また、SDKの内部で行った作業もtraceDeactivationにより中止されます。

Background/Foregroundの移動の際、上記の関数を呼び出さないと、ゲーム利用時間を正確に測定することができないため、このAPIは必ず呼び出さなければなりません。 

DAUは一日にtraceActivationを呼び出したユーザー（Advertise IDまたはUser ID基準）の重複を除いた数値で計算されます。

```java
import com.toast.android.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onResume()
  {
    // foreground状態に切り替わったことをサーバーに知らせる
    GameAnalytics.traceActivation(this);
  }

  @Override
  protected void onPause()
  {
    // background状態に切り替わったことをサーバーに知らせる
    GameAnalytics.traceDeactivation(this);
  }
}
```


##アクション追跡

In-App Purchase、財貨獲得/使用、レベルアップ、友だち数の変更など、ユーザーのActionに対して追跡できます。

###In-App Purchase

In-App Purchaseの発生後、tracePurchaseを呼び出し、売上情報を送信します。

Currencyは、ISO-4217（http://en.wikipedia.org/wiki/ISO_4217）に定義されているコードを使います。

$0.99の宝石を購入する場合、次のようになります。

（ここで、「GEM_10」は、ゲームに定義されているItemのCodeです。Unit Costは、そのアイテムの単位価格、Paymentは実際にユーザーが使った金額です。Levelは購入したユーザーのLevelを入力します。）

```java
GameAnalytics.tracePurchase("GEM_10", 0.99f, 0.99f, "USD", 10);
```


###財貨獲得/使用

ゲーム内の財貨の獲得/使用時に呼び出します。1次財貨、2次財貨の変動量を追跡します。一般的に、1次財貨はIn-App Purchaseを通じて購入する財貨（ex. 宝石、ルビーなど）です。2次財貨は、1次財貨を利用して購入する財貨（ex. チェリー、ハートなど）です。 

IAPを通じて宝石10個を購入した場合、以下のように使います。
（「CODE_IAP」は、ゲームに定義されているCodeです。1次財貨の場合、Typeは0、2次財貨の場合は1を使います。）

```java
GameAnalytics.traceMoneyAcquisition("CODE_IAP", "0", 10, 10);
```
宝石10個でチェリーを100個購入した場合は、次のようになります。

```java
// 1次財貨の使用
GameAnalytics.traceMoneyConsumption("CODE_USE_GEM", "0", 10, 10);

// 2次財貨の獲得
GameAnalytics.traceMoneyAcquisition("CODE_BUY_CHERRY", "1", 100, 10);
```

1次財貨を使って2次財貨を購入した場合、「1次財貨の減少」->「2次財貨の増加」が発生します。しかし、2次財貨を購入する際、1次財貨を使うケースを財貨減少として捉えたくないなら「2次財貨獲得」ログのみの送信でも構いません。

###レベルアップ

ユーザーレベルが変更される場合、traceLevelUpを呼び出します。ちなみに、ほとんどのアクション追跡APIは、レベルごとにアクションを追跡するためにユーザーLevelも一緒に受け取ります。

ユーザーレベルが10に変更される場合、以下のように呼び出します。一人のユーザーのレベルは、必ず上がらなければなりません。レベルが下がるとデータを正確に測定することができません。

例えば、「Candy Crush Sage」のようなステージ型のゲームで、ステージをレベルとして捉えます。このような場合は、ステージへの初回アクセスのみレベルアップログを記録します。もし、前のステージに戻ってプレイし直す場合、レベルアップログは残しません。

また、他のAPIに送信されるlevel値も、現在プレイしているステージではなく、ユーザーの最高ステージをレベル値として使う必要があります。

```java
GameAnalytics.traceLevelUp(10);
```


###友だち

ユーザーの友だちの数を登録します。一般的にアプリの起動後、友だち情報の読み込みが全て完了したタイミングで呼び出します。

```java
GameAnalytics.traceFriendCount(100);
```


#選択的連動

基本連動により提供される基本指標のほかに、ゲームでさらに測定したい指標がある場合、またはAnalyticsから提供されるCampaign機能を使う場合の方法について説明します。

追加連動が可能な項目は以下のとおりです。

*Campaignの連動：setCampaignListener, (show/hide)Campaign
*Custom Eventの収集：traceEvent
*所用時間の測定：traceStartSpeed, traceEndSpeed


##キャンペーンの連動

###キャンペーン連動のための事前準備
キャンペーン連動および実施に関するガイドを別途提供しています。
Toast Analyticsの「キャンペーン実施」メニューの「ページガイド」をご参照ください。
<http://analytics.toast.com/promotion/share/document/4.2_Campaign_run.pdf>

###プッシュの連動
Analytics SDKでキャンペーンのためのPushを使うためには、Toast Cloud Pushを使用する必要があります。
Push使用に関する内容全般は、Toast Cloud Push提供の「Client SDK Guide」を参考にしていください。

<http://docs.cloud.toast.com/ko/Notification/Push/Client%20SDK%20Guide/>

Push使用するためには、AndroidManifest.xmlファイルに加え、Toast Cloud Push SDK提供のcustom recieverを登録する必要があります。

```xml 
<manifest>
  ……
  <application>
    ……
    <!-- GCMを使用する場合 -->
    <service android:name="com.toast.android.analytics.receiver.GcmBroadcastReceiver" android:exported="false">
            <intent-filter>
                <action android:name="com.google.android.c2dm.intent.RECEIVE" />
            </intent-filter>
    </service>
    
    <!-- Tencentを使用する場合 -->
    <receiver android:name="com.toast.android.analytics.receiver.TencentBroadcastReceiver">
        <intent-filter>
            <action android:name="com.tencent.android.tpush.action.PUSH_MESSAGE" />
            <action android:name="com.tencent.android.tpush.action.FEEDBACK" />
        </intent-filter>
    </receiver>
    …… 
    </application>
</manifest>
```

サーバーからPush（GCM）メッセージを受け取ると、Analytics SDKはNotification Barに通知を表示します。この通知を押すとアプリが立ち上がります。この際、特に設定等を行わない限り、該当するアプリのMain Activityが表示されます。

Main Activityではない他のActivityを実行するためには、「setPushIntent」関数を通じて明示的に指定する必要があります。

```java
import com.toast.android.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate();
    ……
    int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppID”, “CompanyID”, “AppVersion”, true);

    if(result != GameAnalytics.S_SUCCESS) {
        Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));
    }
    ……
    Intent intent = new Intent(getApplicationContext(), GCMActivity.class);
    GameAnalytics.setPushIntent(intent);
    ……
} 
```

また、AndroidManifest.xmlにあるActivityのlaunchModeをsingeTop、singleTask、singleInstanceに設定する場合、新しいActivityを作成せず、既存のものをもう一度使います。

この際、Pushに対する情報が含まれたIntent情報をきちんと受け取るには、該当するActivityで「onNewIntent」を明示的にOverrideする必要があります。

```java
public class TestActivity extends Activity {
    
  @Override
  protected void onNewIntent(Intent intent) {
    super.onNewIntent(intent);
    setIntent(intent);
  }
}
```

次に、Toast Cloud Push SDK提供のregister関数で因子として設定した使用者ID情報をGameAnalytics.tracePushUserId関数の因子として設定し、呼び出す必要があります。この使用者ID情報は、GameAnalytics.setUserIdで設定できる使用者IDと異なることもあります。必ず、register関数の因子として使った使用者ID情報でなければなりません。register関数に対する詳細は、Toast Cloud Push提供の「Client SDK Guide」を参考にしてください。

<http://docs.cloud.toast.com/ko/Notification/Push/Client%20SDK%20Guide/>

```java
import com.toast.android.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState)
  {
    super.onCreate();
    ……
    int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppKey”, “CompanyID”, “AppVersion”, true);

    if(result != GameAnalytics.S_SUCCESS) {
        Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));
    }
    ……
    // Toast Push SDK 
    int error = PushSdk.register(APP_KEY, UID, new PushSdk.OnRegister() {
        @Override
        public void fire(int error) {
            if (error == 0) {
                 // 登録完了後、UIDを因子として呼び出す 
                GameAnalytics.tracePushUserId(UID); 
            } 
        }
    }
……
```

###キャンペーンListenerの実装および登録

SDKは一定の周期でキャンペーンサーバーと通信し、キャンペーンおよびリワード情報を受け取ります。もし、現在ユーザーが参加できるキャンペーンが行われているか、ユーザーが受け取るリワード情報がある場合、CampaignListenerを通じて知らせます。

したがって、、キャンペーン情報を受け取るためには、CampaignListenerを実装する必要があります。

```java
public interface CampaignListener {
    void onMissionComplete(List<String> missionList);
    void onCampaignVisibilityChanged(String adSpaceName, boolean show);
    void onCampaignLoadSuccess(String adSpaceName);
    void onCampaignLoadFail(String adSpaceName, CampaignException exception);
    void onCampaignClick(String callbackInfo);   
    void onPromotionVisibilityChanged(boolean show);
}
```

各Callbackは、以下のような場合に呼び出されます。

* onCampaignVisibilityChanged：showCampaign、hideCampaignを呼び出し、キャンペーンに関するポップアップやバナーの表示/非表示の際に呼び出されます。   
* onMissionComplete：ユーザーがキャンペーンおよびプロモーションに参加し、特定のミッションを達成してリワード情報がある場合に呼び出されます。ここで受け取った情報を利用し、ゲームサーバーを通じてリワードを付与する必要があります。キャンペーンのリワードに関するプロセスは、「キャンペーン適用ガイド」をご参照ください。   
* onCampaignLoadSuccess、onCampaignLoadFail：サーバーから受け取ったキャンペーン情報のパージング結果を表示します。ゲームではこのCallbackで特別な処理をする必要はありません。ログ確認のために提供するCallbackです。   
* onCampaignClick : リンクタイプをDeeplinkに選択した場合、登録した文字列を送信するCallbackです。
ここから送られた文字列を参考し、ゲーム内の動作を処理します。
* onPromotionVisibilityChanged：Promotionを使う場合、Promotion Viewの表示/非表示の際に呼び出されます。

実装したCampaignListenerは、setCampaignListenerを使って登録します。

```java
public void setListener() {
  ……
  GameAnalytics.setCampaignListener(new MyCampaignListener() {
    public void onCampaignVisibilityChanged(String adSpaceName, boolean show) {
      ……
    }

    public void onCampaignLoadSuccess(String adSpaceName) {
      // for Debugging
    }

    public void onCampaignLoadFail(String adSpaceName, CampaignException exception) {
      // for Debugging
    }

    public void onMissionComplete(List<String> missionList) {
      // missionList Stringにはkey/value情報が区切り文字「|」で提供されます。
      // この値に基づいてゲームサーバーを通じてpromotion serverで検証を行い、ユーザーに
      // リワードを付与します。
    }
    
    void onCampaignClick(String callbackInfo) {
      // リンクタイプをDeeplinkに選択した場合、登録した文字列を送信するCallbackです。
      // ここから送られた文字列を参考し、ゲーム内の動作を処理します。
    }
    
    public void onPromotionVisibilityChanged(boolean show) {
      // Promotion Viewのオープンの際、showがtrueに送信されます。
      // showがtrueの場合、ゲームのレンダリング性能を低減する作業が行えます。
      // 一方、showがfalseの場合、ゲームのレンダリング性能を元に戻せます。
    }
  });
}
```

###キャンペーンShow/Hide
現在利用者に実施しているキャンペーンがある場合、Analyticsウェブサイトに登録済みのキャンペーンポップアップ/バナーを表示し、表示されたポップアップ/バナーを隠すメソッドです。adspaceNameパラメータは、Analyticsウェブサイトでキャンペーン登録時に定義したadspaceの名前を使います。Adspaceとは、ポップアップ/バナーが表示されるゲーム内の特定場所を意味します。

showCampaign()メソッドは、該当するadspaceを使うキャンペーンがなければ動かないため、キャンペーンポップアップ/バナーを表示すると予想されるゲーム内の複数のポイントに、それぞれ違うadspaceNameで関数を呼び出しておくと、それ以降のポップアップ/バナーの表示は、別のゲームクライアントの修正無しでゲームの利用者がAnalyticsウェブサイトにキャンペーンを登録する作業だけで可能になります。
Adspaceの登録方法は、「キャンペーンテストガイド」をご参照ください。

```java
public static int showCampaign(String adspaceName, Activity activity)
public static int showCampaign(String adspaceName, Activity activity, int animation, int lifeTime) 
public static int hideCampaign(String adspaceName)
public static int hideCampaign(String adspaceName, int animation)
```

##カスタマイズイベント使用

ゲームごとに特定イベントを定義し、分析したい場合に使います。

例えば、Fever Time Itemを使う場合、次のようになります。使われた全てのコードは、ゲームで定義して使います。以下の例題は、特定ステージにおけるアイテム変動を追跡するために定義したコードです。

```java
GameAnalytics.traceEvent("ITEM", "ITEM_USE", "FEVER", "STAGE_10", 1, 10);
```

特定レベルにおけるボスバトルの結果を追跡する時も使います。

```java
GameAnalytics.traceEvent("STAGE", "STAGE_BOSS_VICTORY", "DRAGON_VALLEY", "BOSS_MOB", 1, 10);
```

そのほかにも、様々な形でゲームに特化したイベントの追跡に使います。

traceEventに使用するString Typeパラメータ（event type, event code, param1, param2）は、それぞれ50byteまで使うことができます。そして、event下位に作成可能なparam1は300まで、さらにparam1の下位に作成可能なparam2は200まで使うことができます。

Event Codeは、必ずUniqueである必要があります。Event Typeが異なっても、同じEvent codeの場合、指標がSumされ、紹介されますので、実装時には注意してください。

詳細はToast Analyticsサイトのガイドをご参照ください（カスタマイズイベントページの右上にある「ページガイド」クリックすれば、ダウンロードできます）。


##プロモーション連動

ゲームで他のゲームとプロモーション連動を行う場合に使います。

###プロモーション連動のための事前準備
プロモーション連動および実施に関するガイドを、別途提供しています。

###プロモーションボタンの追加
Analytics設定ページでプロモーション情報を登録してから、ボタン画像を登録すれば、SDKの初期化の際、ボタンをダウンロードしてDeviceに保存します。

ゲームではボタン画像を利用し、適切な場所にボタンを作成しなければなりません。

ボタンを作成する前に、まずプロモーションが可能な状態かを確認します。利用者がAnalyticsのウェブページでプロモーションを使わないと設定している場合、ボタン画像のダウンロードに失敗した場合、またはプロモーションサービスのメンテナンスや障害時には、プロモーション実施が不可能なため、ボタンを画面に表示してはいけません。「isPromotionAvailable()」でプロモーションの実施可否を確認することができます。プロモーション実施が可能な状態であれば、「getPromotionButtonImagePath()&rdqou;」関数を利用し、ボタン画像のパスを確認して、ゲームで適切な場所にボタンを作成します（ボタン画像はPNGタイプで保存します）。

（Analytics設定に登録した画像を使わず、ゲーム配信パッケージに含まれている画像を使ってボタンを作成することも可能です。ただし、この場合も、プロモーションの実施可否を必ず確認-isPromotionAvailable-した後、ボタンを作成する必要があります。）

```java
if (GameAnalytics.isPromotionAvailable()) {
    String buttonImagePath = GameAnalytics.getPromotionButtonImagePath();
    Drawable d = new BitmapDrawable(context.getResources(), buttonImagePath);
    ……
} else {
    Log.d("Hide Toast Promotion Button");
}
```

###プロモーションの実施
プロモーションボタンをタッチする場合、「launchPromotionPage()」を呼び出し、プロモーションを実施します。

```java
private void touchPromotionButton() {
    ……
    GameAnalytics.launchPromotionPage(getActivity());
    ……
}
```

「launchPromotionPage()」では、内部的にWebViewを使い、プロモーションコンテンツを提供します。この機能を使うためには、AndroidManifet.xml設定に該当するActivityを追加する必要があります。

横/縦画面を固定させるためには、android:screenOrientationを利用すると設定できます。 (<http://developer.android.com/guide/topics/manifest/activity-element.html#screen>)

```xml
<activity
    android:configChanges="keyboard|keyboardHidden|orientation|
        screenLayout|uiMode|screenSize|smallestScreenSize"
    android:name="com.toast.android.analytics.PromotionActivity" />
```

さらに、アプリインストール/起動時に広告効果を測定するために、Install Receiverを登録する必要があります。

Install Receiverはプロモーションを通じてアプリをインストールした場合（Google Playのみ可能）、効果測定のために必要です。Execution Receiverは、アプリがインストールされている場合、プロモーションを通じて実施効果を測定するために必要です。「2.2.2. AndroidManifest設定」をご参照ください。

###リワード
ユーザーにプロモーションページが表示されている場合、リワードを付与します。さらに、プロモーションを通じてアプリをインストールしたり、特定のミッションを達成した場合にもリワードを付与します。

リワードに関する情報は、「CampaignListener」の「onMissionComplete」を通じて送信されます。

リワード処理の手続きは、「プロモーションの適用および運営ガイド」ドキュメントをご参照ください。


##所用時間の測定

特定区間における所要時間が測定できます。例えば、チュートリアルの所要時間やSceneの切替にかかる時間を測定したい場合など、時間の測定が必要な任意区間に使用できます。

Intro Sceneを読み込む時間を測定したい場合、以下のように使います。「INTRO_LOADING」は、特定区間に対し、ゲームで定義する値です。

```java
private void onStart() {
    GameAnalytics.traceStartSpeed("INTRO_LOADING");
}

private void onLoadCompleted() {
    GameAnalytics.traceEndSpeed("INTRO_LOADING");
}
```

##Facebookインストール追跡

Facebook広告を通じたアプリインストールを追跡できます。本機能は、Facebookで提供しているDeep Linking機能を参照します。
上記に関する詳細及びテスト方法は、Facebook提供のドキュメント（<https://developers.facebook.com/docs/app-ads/deep-linking>）を参考にしてください。ApplinkData.fetchDeferredAppLinkDataは、Facebook SDKで提供しているAPIです。
(<https://developers.facebook.com/docs/reference/android/current/class/AppLinkData/>)

```java 
AppLinkData.fetchDeferredAppLinkData(this,
    new AppLinkData.CompletionHandler() {
        @Override
            public void onDeferredAppLinkDataFetched(AppLinkData appLinkData) {
                if (appLinkData != null) {
                    GameAnalytics.traceFacebookInstall(context, String.valueOf(appLinkData.getTargetUri()));
                }
            }
        }
);}
```


#SDKの設定

##デバッグモードの有効化
開発中にSDKログを確認するため、ログの出力有無を設定することができます。

この関数は、initializeSDK以前/以降、どちらも呼び出し可能です。デフォルト値は、setDebugMode(false)です。

Log tagsは「Analytics:」から始まります。Eclipseでlog cat filterを「Analytics」に指定すれば、SDKで発生するログを確認することができます。)

```java
private void Start () {
     ……
     GameAnalytics.setDebugMode(true);
     ……

     int result = GameAnalytics.initializeSdk ("APPKEY", "COMPANYID", "VERSION", false);

     if (result != 0) {
        // SDK初期化失敗
     }
     ……
}
```

デバッグモードが有効になった場合、ログ送信内容を確認することができます。ログを送信し、それに対するレスポンスログを確認することで、ログが正常に送信されたか確認できます。収集済みのデータのサーバーへの送信が正常終了すると、以下のようなログ文字列が表示されます。 （***は、場合によって違う値になります）。

```
Android：server response (***)：200 OK
```


##デバイス情報の確認
SDKに収集されるDevice情報を確認することができます。

現在確認できる値は、Device ID、Push User ID、Campaign User IDです。これらの値は、キャンペーン連動テストの際に必要です。詳細は、「キャンペーン連動ガイド」をご参照ください。

Device情報を確認するために使うKeyです。
- public static final String DEVICE_INFO_DEVICEID = “deviceId”;
- public static final String DEVICE_INFO_PUSH_USERID = “pushUserId”;
- public static final String DEVICE_INFO_CAMPAIGN_USERID = ”campaignUserId”;

```java
private void printDeviceInfo() {
     String deviceID = GameAnalytics.getDeviceInfo(GameAnalytics.DEVICE_INFO_DEVICEID);
     String pushUserID = GameAnalytics.getDeviceInfo(GameAnalytics.DEVICE_INFO_PUSH_USERID);
     String campaignUserID = GameAnalytics.getDeviceInfo(GameAnalytics.DEVICE_INFO_CAMPAIGN_USERID);
     ……
}
```

##SDKバージョン確認
SDKバージョンは、「GameAnalytics.getVersion()」関数を通じて確認できます。

```java
public static String getVersion()
```

